# 206. Reverse Linked List — Notes

## Intuition
Reversing a linked list means changing the direction of its pointers.  
Initially, each node points forward, and we want to flip all the arrows so the head becomes the tail and vice versa.  
This can be done by carefully walking through the list and re-wiring the links one by one without losing track of the remaining nodes.

## Approach
We use an **iterative three-pointer technique**:

1. `prev` keeps track of the node that should come before the current one in the reversed list (initially `nullptr`).
2. `curr` points to the node we are processing.
3. `next` temporarily stores the original next node so we don’t lose the rest of the list when flipping the link.

At each step:
- Save the next node (`next = curr->next`).
- Reverse the link (`curr->next = prev`).
- Advance `prev` forward (`prev = curr`).
- Advance `curr` forward (`curr = next`).

The loop ends when `curr` reaches `nullptr`. At this point, `prev` points to the new head of the reversed list.

---

### Code (Iterative)

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* curr = head;
        ListNode* next = nullptr;

        while (curr) {
            next = curr->next;   // Store next node
            curr->next = prev;   // Reverse link
            prev = curr;         // Move prev forward
            curr = next;         // Move curr forward
        }
        return prev; // New head
    }
};
````

### Code (Recursive)

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next) return head;
        ListNode* newHead = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return newHead;
    }
};
```

## Complexity

* **Time Complexity:** O(n), where n is the number of nodes (each node is visited once).
* **Space Complexity:**

  * Iterative: O(1) (just three pointers).
  * Recursive: O(n) (stack frames for recursion).

## Takeaway

The iterative solution is generally preferred for its constant space usage.
The recursive version is elegant and expressive, but for very large lists it risks stack overflow.
